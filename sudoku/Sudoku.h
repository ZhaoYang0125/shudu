#pragma once
#include <iostream>
#include <fstream>
#include <sstream>
#include <cassert>
#include <cstring>
#include <cstdio>
#include <string>
#include <utility>
#include "utils.h"

constexpr char STAT_FILE[] = "freedom.txt";	// dump statistics of freedom degree to file `freedom.txt`
constexpr char PUZZLE_OUT_FILE[] = "puzzle_generated.txt";
constexpr char FINALE_FILE[] = "finale.txt";
constexpr char SOLUTION_FILE[] = "solution.txt";	// solution of puzzles

/* limitations */
constexpr int MIN_FINALE = 1;			// minimum of final results
constexpr int MAX_FINALE = (int)1e6;	// maximum of final results

constexpr int MIN_PUZZLE = 1;			// minimum of games
constexpr int MAX_PUZZLE = (int)1e4;	// maximum of games

constexpr int MIN_DIFFICULTY = 1;		// minimum of difficulty
constexpr int MEDIUM_DIFFICULTY = 2;
constexpr int MAX_DIFFICULTY = 3;		// maximum of difficulty

constexpr int MIN_BLANK = 20;			// minimum of blanks
constexpr int MAX_BLANK = 55;			// maximum of blanks

constexpr float HARD_RATIO = 0.15f;		// ratio of difficulty split 3:6:11
constexpr float MEDIUM_RATIO = 0.30f;
constexpr float SIMPLE_RATIO = 0.55f;

/* logo `sudoku` */
constexpr char LOGO[] = {
	" ____            _       _          \n"
	"/ ___| _   _  __| | ___ | | ___   _ \n"
	"\\___ \\| | | |/ _` |/ _ \\| |/ / | | |\n"
	" ___) | |_| | (_| | (_) |   <| |_| |\n"
	"|____/ \\__,_|\\__,_|\\___/|_|\\_\\\\__,_|\n"
	"                                    "
};

/* usage of the executable */
// because of an encoding problem between file and console, 
// Chinese words are printed wrongly
// #define CHINESE_USAGE
#ifndef CHINESE_USAGE
constexpr char USAGE[] = {
	"name       meaning                                                 range                       example\n"
	"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
	"-c         number of finales to be generated                       1-1000000                   suduku.exe -c 20 [generate 20 finales]\n"
	"-s         file path of puzzles to be solved                       relative or absolute path   suduku.exe -s game.txt [solving puzzles stored at `puzzle.txt`，dumping solution to `solution.txt`]\n"
	"-n         number of puzzles to be generated                       1-10000                     suduku.exe -n 1000 [generating 1000 puzzles]\n"
	"-m         difficulty of puzzles to be generated                   1-3                         suduku.exe -n 1000 -m 1 [both `n` and `m` are needed]\n"
	"-r         number of blanks of puzzles to be generated             20-55                       suduku.exe -n 20 -r 20-55 [both `n` and `r` are needed]\n"
	"-u         whether the solution of a generated puzzle is unique                                suduku.exe -n 20 -u [both `n` and `u` are needed]\n"
	"-h         print help message                                                                  suduku.exe -h\n"
};
#else // CHINESE_USAGE
const char usage[] = {
	"参数名字   参数意义                    范围限制        用法示例\n"
	"-----------------------------------------------------------------------------------------------------------------------------------------------------------\n"
	"-c         需要的数独终盘数量          1-1000000       suduku.exe -c 20 [表示生成20个数独终盘]\n"
	"-s         需要解的数独棋盘文件路径     绝对或相对路径    suduku.exe -s game.txt [表示从puzzle.txt读取若干个数独游戏，并给出其解答，生成到solution.txt中]\n"
	"-n         需要的游戏数量              1-10000         suduku.exe -n 1000 [表示生成1000个数独游戏]\n"
	"-m         生成游戏的难度              1-3             suduku.exe -n 1000 -m 1 [表示生成1000个简单数独游戏，只有m和n一起使用才认为参数无误]\n"
	"-r         生成游戏中挖空的数量范围     20-55           suduku.exe -n 20 -r 20-55 [表示生成20个挖空数在20到55之间的数独游戏，只有r和n一起使用才认为参数无误]\n"
	"-u         生成游戏的解唯一                            suduku.exe -n 20 -u [表示生成20个解唯一的数独游戏，只有u和n一起使用才认为参数无误]\n"
	"-h         显示帮助                                    suduku.exe -h [表示打印帮助信息]\n"
};
#endif

constexpr char CHARACTER_MAP[] = { '$', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
const char* DIFFICULTY_MAP[] = { "\0", "easy", "medium", "hard" };

/* difficulty spit params are generated by prior work of `split_difficulty` */
constexpr int BLANKS_HARD_THRESH[MAX_BLANK - MIN_BLANK + 1] = { 
	126, 138, 152, 164, 180, 194, 
	208, 226, 242, 258, 276, 294, 
	314, 332, 352, 372, 394, 416, 
	438, 462, 484, 508, 534, 558, 
	582, 610, 638, 664, 692, 722, 
	750, 780, 812, 842, 874, 906 };
constexpr int BLANKS_MEDIUM_THRESH[MAX_BLANK - MIN_BLANK + 1] = { 
	114, 126, 140, 152, 166, 180, 
	194, 210, 226, 242, 260, 278, 
	298, 316, 336, 356, 378, 400, 
	422, 446, 468, 492, 518, 542, 
	566, 594, 620, 648, 676, 706, 
	736, 764, 796, 826, 858, 892 };
constexpr int TOTAL_HARD_THRESH = 738;
constexpr int TOTAL_MEDIUM_THRESH = 450;

class Sudoku
{
private:
	int _n_finale = 0;					// number of final results
	char* _input = nullptr;				// file path of games (both relative and absolute path are ok)
	int _n_puzzle = 0;					// number of games to be generated
	int _difficulty = 0;				// difficulty (easy, middle or hard, default is easy)
	int _n_blank = 0;					// number of blanks
	bool _unique = false;				// whether solution is unique (default is not)

public:
	Sudoku() {}
	~Sudoku() { if (_input != nullptr) { delete[]_input; _input = nullptr;  } }

	/*
	Init sudoku object with input params
	*/ 
	void init(int n_finale, char* input, int n_puzzle, int difficulty, int n_blank, bool unique)
	{
		// at this time, we do not know which function the user needs
		// so we check the legality of params when calling corresponding functions
		_n_finale = n_finale;
		if (input != nullptr) {	// deepcopy in case that `input` is out of its lifetime
			size_t length = strlen(input);
			_input = new char[length + 1];
			strncpy_s(_input, length + 1, input, length);
		}
		_n_puzzle = n_puzzle;
		_difficulty = difficulty;
		_n_blank = n_blank;
		_unique = unique;
	}

	/* 
	Generate sudoku finals.
	*/
	void generate_finales() const
	{
		std::ofstream finale_file(FINALE_FILE);
		std::cout << "Generating " << _n_finale << " finales..." << std::endl;
		finale_file << "Generating " << _n_finale << " finales...\n";
		int board[9][9];
		char board_str_fmt[1024];
		char result_str[1024];

		for (int i = 0; i < _n_finale; i++) {
			gen_finale(board);
			board_to_str_fmt(board, board_str_fmt, 1024);
			snprintf(result_str, 1024, "Finale %d:\n%s\n", i + 1, board_str_fmt);
			std::cout << result_str;
			finale_file << result_str;
		}

		std::cout << "All " << _n_finale << " finale(s) have(has) been generated." << std::endl;
		finale_file << "All " << _n_finale << " finale(s) have(has) been generated.\n";
		finale_file.close();
	}

	/*
	Generate sudoku puzzles.
	*/
	void generate_puzzles() const
	{
		std::ofstream puzzle_out_file(PUZZLE_OUT_FILE);
		std::cout << "Generating " << _n_puzzle << " puzzles..." << std::endl;
		puzzle_out_file << "Generating " << _n_puzzle << " puzzles...\n";
		int board[9][9];
		char board_str_fmt[1024];
		char result_str[1024];

		for (int i = 0; i < _n_puzzle; i++) {
			gen_puzzle(board);
			board_to_str_fmt(board, board_str_fmt, 1024);
			snprintf(result_str, 1024, "Puzzle %d, n_blank: %d, difficulty: %s\n%s\n", i + 1, get_board_blanks(board), DIFFICULTY_MAP[analyze_difficulty(board)], board_str_fmt);
			std::cout << result_str;
			puzzle_out_file << result_str;
		}
		std::cout << "All " << _n_puzzle << " puzzle(s) have(has) been generated." << std::endl;
		puzzle_out_file << "All " << _n_puzzle << " puzzle(s) have(has) been generated.\n";
	}

	/*
	Read games from input and solve them.
	Solutions will be dump to `output.txt`
	*/
	void read_and_solve() const
	{
		std::ifstream puzzle_file(_input);
		std::ofstream solution_file(SOLUTION_FILE, std::ios::trunc);
		std::string line("");
		int puzzle_cnt = 0;
		char board_str_fmt[1024] = { 0 };
		char result_str[1024] = { 0 };
		while (std::getline(puzzle_file, line)) {
			puzzle_cnt++;
			int board[9][9] = { 0 };
			std::string puzzle_name("");

			char flag = line[0];	// determine which format the board is

			// format 1: a line expresses a puzzle, like
			// `705308000086000007000060090952870604300000109018439702000180023020906070500000008`
			// or `7$53$8$$$$86$$$$$7$$$$6$$9$95287$6$43$$$$$1$9$184397$2$$$18$$23$2$9$6$7$5$$$$$$$8`
			// which is quick to input
			if ((flag >= '0' && flag <= '9') || (flag == '$')) {
				puzzle_name += std::to_string(puzzle_cnt);
				char* ptr = &line[0];
				for (int i = 0; i < 9; i++) {
					for (int j = 0; j < 9; j++) {
						char c = *ptr++;
						board[i][j] = (c == '$') ? 0 : (c - '0');
					}
				}
			}

			// format 2: like:
			/*  game1				# game name, a string (cannot start with `$`)
				8 6 7 1 $ $ 2 $ 5	# board, `0` can be represented as `0` or `$`
				$ $ $ $ 8 $ 1 $ 7
				$ $ $ $ $ $ 8 4 $
				1 3 $ 6 7 $ $ $ 8
				7 $ $ 2 $ 1 $ $ 6
				6 $ $ $ 9 8 $ 5 1
				$ 7 1 $ $ $ $ $ $
				3 $ 2 $ 5 $ $ $ $
				5 $ 6 $ $ 2 3 7 9 */
			// which is intuitive
			if ((flag < '0' || flag > '9') && (flag != '$')) {
				puzzle_name += line;
				for (int i = 0; i < 9; i++) {
					std::getline(puzzle_file, line);
					std::stringstream ss(line);
					char c = '0';
					for (int j = 0; j < 9; j++) {
						ss >> c;
						board[i][j] = (c == '$') ? 0 : (c - '0');
					}
				}
			}

			solve_puzzle(board);
			board_to_str_fmt(board, board_str_fmt, 1024);

			snprintf(result_str, 1024, "Solution for %s:\n%s\n", puzzle_name.c_str(), board_str_fmt);
			std::cout << result_str;
			solution_file << result_str;
		}
		puzzle_file.close();
		solution_file.close();
	}

	/*
	Solve puzzle using dfs and backtracking method
	*/
	void solve_puzzle(int board[9][9]) const
	{
		bool row[9][10] = { false };	// whether a num exist in row[i]
		bool col[9][10] = { false };
		bool box[3][3][10] = { false };
		std::vector<std::pair<int, int>> spaces;	// positions of spaces
		
		// record spaces
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				int num = board[i][j];
				if (!num) {
					spaces.emplace_back(i, j);
				}
				else {
					row[i][num] = col[j][num] = box[i / 3][j / 3][num] = true;
				}
			}
		}

		// solve by dfs and backtracking
		DFS(board, spaces, 0, row, col, box);
	}

	/*
	Define a deep-first-strategy
	*/
	void DFS(int board[9][9], std::vector<std::pair<int, int>> &spaces, int n_space_filled, bool row[9][10], bool col[9][10], bool box[3][3][10]) const
	{
		if (spaces.size() == (size_t)n_space_filled) {	// all spaces are filled
			return;
		}
		int r = spaces[n_space_filled].first;
		int c = spaces[n_space_filled].second;
		for (int num = 1; num <= 9; num++) {
			if (!row[r][num] && !col[c][num] && !box[r / 3][c / 3][num]) {
				row[r][num] = col[c][num] = box[r / 3][c / 3][num] = true;
				board[r][c] = num;
				DFS(board, spaces, n_space_filled + 1, row, col, box);
				row[r][num] = col[c][num] = box[r / 3][c / 3][num] = false;
			}
		}
	}

	/* 
	* Print usage of how to play 
	*/
	static void print_usage() { std::cout << USAGE; }

	/*
	Convert 9 * 9 board into a flattened string
	`0` will be maped to `$`
	*/
	void board_to_str(int board[9][9], char* board_str) const
	{
		int* ptr_src = nullptr;
		char* ptr_dst = board_str;
		for (int i = 0; i < 9; i++) {
			ptr_src = board[i];
			for (int j = 0; j < 9; j++) {
				int idx = *ptr_src;
				*ptr_dst++ = CHARACTER_MAP[*ptr_src++];
			}
		}
	}

	/*
	Convert 9 * 9 board into a formatted string
	`0` will be maped to `$`
	*/
	void board_to_str_fmt(int board[9][9], char* board_str_fmt, int buf_sz) const
	{
		char board_str[81];
		board_to_str(board, board_str);
		char* s = board_str;
		snprintf(board_str_fmt, buf_sz,
			"-------------------------\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"-------------------------\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"-------------------------\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"| %c %c %c | %c %c %c | %c %c %c |\n"
			"-------------------------\n",
			s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9],
			s[10], s[11], s[12], s[13], s[14], s[15], s[16], s[17], s[18], s[19],
			s[20], s[21], s[22], s[23], s[24], s[25], s[26], s[27], s[28], s[29],
			s[30], s[31], s[32], s[33], s[34], s[35], s[36], s[37], s[38], s[39],
			s[40], s[41], s[42], s[43], s[44], s[45], s[46], s[47], s[48], s[49],
			s[50], s[51], s[52], s[53], s[54], s[55], s[56], s[57], s[58], s[59],
			s[60], s[61], s[62], s[63], s[64], s[65], s[66], s[67], s[68], s[69],
			s[70], s[71], s[72], s[73], s[74], s[75], s[76], s[77], s[78], s[79],
			s[80]);
	}

	/* 
	Print the board (9 * 9)
	*/
	void print_board(int board[9][9]) const
	{
		char board_str_fmt[1024];
		board_to_str_fmt(board, board_str_fmt, 1024);
		std::cout << board_str_fmt;
	}

	/*
	Generate a finale 
	*/
	void gen_finale(int board[9][9]) const
	{
		empty_board(board);
		backtracking_fill(board);
	}

	/*
	Generate a puzzle from a finale
	*/
	void gen_puzzle(int board[9][9]) const
	{
		naive_poke(board);
	}

	/*
	Check whether insert a num at specific coordinate is safe
	by scanning the row
	*/
	bool row_safe(int board[9][9], int num, int r, int c) const
	{
		if (board[r][c]) {
			return false;		// pos(r, c) already has a number
		}
		for (int j = 0; j < 9; j++) {
			if (board[r][j] == num) {
				return false;	// numbers in a row cannot be the same
			}
		}
		return true;
	}

	/*
	Check whether insert a num at specific coordinate is safe
	by scanning the column
	*/
	bool col_safe(int board[9][9], int num, int r, int c) const
	{
		if (board[r][c]) {
			return false;		// pos(r, c) already has a number
		}
		for (int i = 0; i < 9; i++) {
			if (board[i][c] == num) {
				return false;	// numbers in a row cannot be the same
			}
		}
		return true;
	}

	/*
	Check whether insert a num at specific coordinate is safe
	by scanning the box
	*/
	bool box_safe(int board[9][9], int num, int r, int c) const
	{
		// start coordinates of boxes are
		// (0, 0), (0, 3), (0, 6)
		// (3, 0), (3, 3), (3, 6)
		// (6, 0), (6, 3), (6, 6)

		int s_r = (r / 3) * 3;
		int s_c = (c / 3) * 3;
		int* ptr = nullptr;
		for (int i = s_r; i < s_r + 3; i++) {
			ptr = board[i] + s_c;
			for (int j = s_c; j < s_c + 3; j++) {
				if (*ptr++ == num) {
					return false;
				}
			}
		}
		return true;
	}

	/*
	Check whether insert a num at specific coordinate is safe
	by scanning the row
	*/
	bool safe_check(int board[9][9], int num, int r, int c) const
	{
		assert(num >= 1 && num <= 9
			&& r >= 0 && r <= 8
			&& c >= 0 && c <= 8);
		return row_safe(board, num, r, c)
			&& col_safe(board, num, r, c)
			&& box_safe(board, num, r, c);
	}

	/*
	Search the board to find a blank or non-blank.
	If found, the coordinate will be saved at `pr` and `pc`, and return true
	else, return false
	`is_blank` controls the next is `blank` or `non-blank`
	`randomly` controls whether the next is chosen randomly
	*/
	bool get_next(int board[9][9], int* pr, int* pc, bool is_blank = true, bool randomly = false) const
	{
		if (!randomly) {
			int* ptr = nullptr;
			for (int i = 0; i < 9; i++) {
				ptr = board[i];
				for (int j = 0; j < 9; j++) {
					if ((bool) (*ptr++) ^ is_blank) {
						*pr = i;
						*pc = j;
						return true;
					}
				}
			}
			return false;
		}
		// randomly choose
		std::pair<int, int> candidates[81];
		int* p_src = nullptr;
		int cnt = 0;
		for (int i = 0; i < 9; i++) {
			p_src = board[i];
			for (int j = 0; j < 9; j++) {
				if ((bool)(*p_src++) ^ is_blank) {
					auto* p_dst = candidates + cnt++;
					p_dst->first = i;
					p_dst->second = j;
				}
			}
		}
		if (!cnt) {
			return false;
		}
		shuffle_array(candidates, cnt);
		*pr = candidates[0].first;
		*pc = candidates[0].second;
		return true;
	}

	/*
	Using backtracking method to fill all blanks in board
	`early_stop` controls whether stoping after finding the first solution.
		if `early_stop` is `true`, we will get the last solution
	`n_solution` counts the number of solutions.
	*/
	bool backtracking_fill(int board[9][9], bool early_stop = true, int* n_solution = nullptr) const
	{
		int r, c;
		if (!get_next(board, &r, &c, true)) {
			return true;
		}
		int arr[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
		shuffle_array(arr, sizeof(arr) / sizeof(int));
		int cnt = 0;
		for (auto num : arr) {
			if (safe_check(board, num, r, c)) {
				board[r][c] = num;
				if (backtracking_fill(board)) {
					cnt++;				// a solution is found
					if (early_stop) {	// if `early_stop`, no need to find the next solution
						break;
					}
				}
				board[r][c] = 0;		// restore to 0 for the next check
			}
		}
		if (n_solution) {
			*n_solution = cnt;
		}
		return !get_next(board, &r, &c, true);
	}

	/*
	Using backtracking method to poke blanks in board.
	If n_blank if specified, then puzzle will match the difficulty parting of corresponding n_blank.
	Else the puzzle will be generated with n_blank randomly chosen to match the global difficulty parting.
	*/
	bool naive_poke(int board[9][9]) const
	{
		int difficulty = 0;
		do {
			int n_blank = _n_blank ? _n_blank : gen_rand_number(MIN_BLANK, MAX_BLANK);
			difficulty = _difficulty ? _difficulty : gen_rand_number(MIN_DIFFICULTY, MAX_DIFFICULTY);
			gen_finale(board);
			while (get_board_blanks(board) < n_blank) {
				int r, c;
				if (!get_next(board, &r, &c, false, true)) {					// randomly get a non-blank
					return false;												// cannot find a non-block to poke
				}
				int tmp_num = board[r][c];
				board[r][c] = 0;
				if (_unique) {													// ensure each poking step does not cause a multi-solution puzzle
					int n_solution = 0;
					int tmp_board[9][9];
					copy_board(board, tmp_board);
					backtracking_fill(tmp_board, false, &n_solution);
					if (n_solution >= 2) {										// causing a multi-solution puzzle, roll back
						board[r][c] = tmp_num;
					}
				}
			}
		} while (analyze_difficulty(board) != difficulty);	// difficulty is specified then generate puzzle until difficulty met
		return true;
	}

	/*
	Set board element to zero
	*/
	void empty_board(int board[9][9]) const
	{
		int* ptr = nullptr;
		for (int i = 0; i < 9; i++) {
			ptr = board[i];
			for (int j = 0; j < 9; j++) {
				*ptr++ = 0;
			}
		}
	}

	/*
	manully set the boardand copy to the dst
	*/
	void copy_board(int src[9][9], int dst[9][9]) const
	{
		int* src_ptr = nullptr, * dst_ptr = nullptr;
		for (int i = 0; i < 9; i++) {
			src_ptr = src[i];
			dst_ptr = dst[i];
			for (int j = 0; j < 9; j++) {
				*dst_ptr++ = *src_ptr++;
			}
		}
	}

	/*
	Count blanks of a board
	*/
	int get_board_blanks(int board[9][9]) const
	{
		int* ptr = nullptr;
		int cnt = 0;
		for (int i = 0; i < 9; i++) {
			ptr = board[i];
			for (int j = 0; j < 9; j++) {
				if (!*ptr++) {
					cnt++;
				}
			}
		}
		return cnt;
	}

	/*
	Count non-blanks of a board
	*/
	int get_board_non_blanks(int board[9][9]) const
	{
		return 81 - get_board_blanks(board);
	}

	int match_difficulty(int freedom_degree, int hard_thresh, int medium_thresh) const
	{
		if (freedom_degree >= hard_thresh) {
			return MAX_DIFFICULTY;
		}
		if (freedom_degree >= medium_thresh) {
			return MEDIUM_DIFFICULTY;
		}
		return MIN_DIFFICULTY;
	}

	/*
	Analyze difficulty depending on blanks number and degrees of freedom.
	If n_blank if specified, then puzzle will match the difficulty parting of corresponding n_blank.
	Else the puzzle will be generated with n_blank randomly chosen to match the global difficulty parting.
	*/
	int analyze_difficulty(int board[9][9]) const
	{
		int freedom_degree = get_board_freedom_degree(board);
		if (_n_blank) {
			int blank_idx = _n_blank - MIN_BLANK;
			return match_difficulty(freedom_degree, BLANKS_HARD_THRESH[blank_idx], BLANKS_MEDIUM_THRESH[blank_idx]);
		}
		return match_difficulty(freedom_degree, TOTAL_HARD_THRESH, TOTAL_MEDIUM_THRESH);
	}

	/*
	Helper of `split_difficulty` to get split threshold of difficulty
	*/
	void reverse_count(const int* bins, int freedom_range, int n_hard_thresh, int n_medium_thresh, std::pair<int, int>& thresh) {
		int hard_cnt = 0, hard_thresh = 0;
		int medium_cnt = 0, medium_thresh = 0;
		for (int freedom_degree = freedom_range - 1; freedom_degree >= 0; freedom_degree--) {
			hard_cnt += bins[freedom_degree];
			if (hard_cnt >= n_hard_thresh) {
				hard_thresh = freedom_degree;
				break;
			}
		}
		for (int freedom_degree = hard_thresh - 1; freedom_degree >= 0; freedom_degree--) {
			medium_cnt += bins[freedom_degree];
			if (medium_cnt >= n_medium_thresh) {
				medium_thresh = freedom_degree;
				break;
			}
		}
		thresh.first = hard_thresh;
		thresh.second = medium_thresh;
		//printf("n_hard_thresh is %d, n_medium_thresh is %d, hard_thresh is %d, medium_thresh id %d\n", n_hard_thresh, n_medium_thresh, hard_thresh, medium_thresh);
		//for (int i = freedom_range - 1; i >= 0; i--) {
		//	std::cout << (bins[i] ? std::to_string(bins[i]) : "_") << ' ';
		//}
		//std::cout << std::endl;
	}

	/*
	Split difficulty depending on blanks number and degrees of freedom
	Simple: Middle: Hard = 3: 6: 11
	*/
	void split_difficulty()
	{
		constexpr int blanks_range = MAX_BLANK - MIN_BLANK + 1;
		constexpr int freedom_range = 9 * 9 * (3 * 3 + 2 * 9 - 3) - 0 + 1;
		constexpr int n_generate = 2000;	// takes 2 min also

		// allocat bins
		int** blanks_bins = allocate_2d_array<int>(blanks_range, freedom_range);
		for (int i = 0; i < blanks_range; i++) {
			for (int j = 0; j < freedom_range; j++) {
				blanks_bins[i][j] = 0;
			}
		}
		int* total_bins = new int[freedom_range];
		for (int i = 0; i < freedom_range; i++) {
			total_bins[i] = 0;
		}

		// randomly generate puzzles
		int board[9][9];
		int n_blank_backup = _n_blank;
		for (int n_blank = MIN_BLANK; n_blank <= MAX_BLANK; n_blank++) {
			_n_blank = n_blank;
			int blank_idx = n_blank - MIN_BLANK;
			for (int t = 0; t < n_generate; t++) {
				gen_finale(board);
				gen_puzzle(board);
				int freedom_degree = get_board_freedom_degree(board);
				//printf("n_blank is %d of %d times, freedom_degree: %d\n", _n_blank, t + 1, freedom_degree);	// works right!
				blanks_bins[blank_idx][freedom_degree]++;
				total_bins[freedom_degree]++;
			}
		}
		_n_blank = n_blank_backup;

		// get statistics
		constexpr int n_hard_thresh = (int)(n_generate * HARD_RATIO);
		constexpr int n_medium_thresh = (int)(n_generate * MEDIUM_RATIO);
		std::pair<int, int> blanks_thresh[blanks_range];	// first: hard_thresh, second: medium_thresh
		std::pair<int, int> total_thresh;
		for (int blank_idx = 0; blank_idx < blanks_range; blank_idx++) {
			reverse_count(blanks_bins[blank_idx], freedom_range, n_hard_thresh, n_medium_thresh, blanks_thresh[blank_idx]);
			//printf("n_blank is %d, hard_thresh is %d, medium_thresh is %d\n", blank_idx + MIN_BLANK, blanks_thresh[blank_idx].first, blanks_thresh[blank_idx].second);
		}
		reverse_count(total_bins, freedom_range, n_hard_thresh * blanks_range, n_medium_thresh * blanks_range, total_thresh);
		//printf("total hard_thresh is %d, medium_thresh is %d\n", total_thresh.first, total_thresh.second);

		// free allocated space
		free_2d_array<int>(blanks_bins, blanks_range);
		delete[]total_bins;
		total_bins = nullptr;

		// dump to file and analyze
		std::ofstream stat(STAT_FILE, std::ios::trunc);
		stat << total_thresh.first << ' ' << total_thresh.second << '\n';
		//for (int n_blank = MIN_BLANK; n_blank <= MAX_BLANK; n_blank++) {
		//	stat << n_blank << ' ' << blanks_thresh[n_blank - MIN_BLANK].first << ' ' << blanks_thresh[n_blank - MIN_BLANK].second << '\n';
		//}
		for (int i = 0; i < blanks_range; i++) {
			stat << blanks_thresh[i].first << ", ";
		}
		stat << '\n';
		for (int i = 0; i < blanks_range; i++) {
			stat << blanks_thresh[i].second << ", ";
		}
		stat.close();
	}

	/*
	degree of freedom of a blank is the sum of blanks number in the same row, col and box
	*/
	int get_blank_freedom_degree(int board[9][9], int r, int c) const
	{
		if (board[r][c]) {	// already has a number. no freedom degree
			return 0;
		}
		int cnt = 0;
		int s_r = (r / 3) * 3;	// box range
		int s_c = (c / 3) * 3;

		// row count
		for (int j = 0; j < 9; j++) {
			if (!board[r][j]) {
				cnt++;
			}
		}

		// col count
		for (int i = 0; i < 9; i++) {
			if (!board[i][c]) {
				cnt++;
			}
		}

		// box count
		for (int i = s_r; i < s_r + 3; i++) {
			for (int j = s_c; j < s_c + 3; j++) {
				if (!board[i][j]) {
					cnt++;
				}
			}
		}

		return cnt - 3;	// except itself
	}

	/*
	degree of freedom of a puzzle is the sum of degrees of freedom of its blanks
	*/
	int get_board_freedom_degree(int board[9][9]) const
	{
		int cnt = 0;
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				cnt += get_blank_freedom_degree(board, i, j);
			}
		}
		return cnt;
	}
};

